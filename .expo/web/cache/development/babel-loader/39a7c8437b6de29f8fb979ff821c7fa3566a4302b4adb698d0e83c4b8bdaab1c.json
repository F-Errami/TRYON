{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from \"../core/shaderMaterial.js\";\nvar WireframeMaterialShaders = {\n  uniforms: {\n    strokeOpacity: 1,\n    fillOpacity: 0.25,\n    fillMix: 0,\n    thickness: 0.05,\n    colorBackfaces: false,\n    dashInvert: true,\n    dash: false,\n    dashRepeats: 4,\n    dashLength: 0.5,\n    squeeze: false,\n    squeezeMin: 0.2,\n    squeezeMax: 1,\n    stroke: new THREE.Color('#ff0000'),\n    backfaceStroke: new THREE.Color('#0000ff'),\n    fill: new THREE.Color('#00ff00')\n  },\n  vertex: `\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  `,\n  fragment: `\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  `\n};\nvar WireframeMaterial = shaderMaterial(WireframeMaterialShaders.uniforms, WireframeMaterialShaders.vertex + `\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  `, WireframeMaterialShaders.fragment + `\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  `);\nfunction setWireframeOverride(material, uniforms) {\n  material.onBeforeCompile = function (shader) {\n    shader.uniforms = _objectSpread(_objectSpread({}, shader.uniforms), uniforms);\n    shader.vertexShader = shader.vertexShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.vertex}\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.fragment}\n\t\t  void main() {\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('#include <color_fragment>', `\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t`);\n  };\n  material.side = THREE.DoubleSide;\n  material.transparent = true;\n}\nfunction useWireframeUniforms(uniforms, props) {\n  React.useEffect(function () {\n    var _props$fillOpacity;\n    return void (uniforms.fillOpacity.value = (_props$fillOpacity = props.fillOpacity) !== null && _props$fillOpacity !== void 0 ? _props$fillOpacity : uniforms.fillOpacity.value);\n  }, [props.fillOpacity]);\n  React.useEffect(function () {\n    var _props$fillMix;\n    return void (uniforms.fillMix.value = (_props$fillMix = props.fillMix) !== null && _props$fillMix !== void 0 ? _props$fillMix : uniforms.fillMix.value);\n  }, [props.fillMix]);\n  React.useEffect(function () {\n    var _props$strokeOpacity;\n    return void (uniforms.strokeOpacity.value = (_props$strokeOpacity = props.strokeOpacity) !== null && _props$strokeOpacity !== void 0 ? _props$strokeOpacity : uniforms.strokeOpacity.value);\n  }, [props.strokeOpacity]);\n  React.useEffect(function () {\n    var _props$thickness;\n    return void (uniforms.thickness.value = (_props$thickness = props.thickness) !== null && _props$thickness !== void 0 ? _props$thickness : uniforms.thickness.value);\n  }, [props.thickness]);\n  React.useEffect(function () {\n    return void (uniforms.colorBackfaces.value = !!props.colorBackfaces);\n  }, [props.colorBackfaces]);\n  React.useEffect(function () {\n    return void (uniforms.dash.value = !!props.dash);\n  }, [props.dash]);\n  React.useEffect(function () {\n    return void (uniforms.dashInvert.value = !!props.dashInvert);\n  }, [props.dashInvert]);\n  React.useEffect(function () {\n    var _props$dashRepeats;\n    return void (uniforms.dashRepeats.value = (_props$dashRepeats = props.dashRepeats) !== null && _props$dashRepeats !== void 0 ? _props$dashRepeats : uniforms.dashRepeats.value);\n  }, [props.dashRepeats]);\n  React.useEffect(function () {\n    var _props$dashLength;\n    return void (uniforms.dashLength.value = (_props$dashLength = props.dashLength) !== null && _props$dashLength !== void 0 ? _props$dashLength : uniforms.dashLength.value);\n  }, [props.dashLength]);\n  React.useEffect(function () {\n    return void (uniforms.squeeze.value = !!props.squeeze);\n  }, [props.squeeze]);\n  React.useEffect(function () {\n    var _props$squeezeMin;\n    return void (uniforms.squeezeMin.value = (_props$squeezeMin = props.squeezeMin) !== null && _props$squeezeMin !== void 0 ? _props$squeezeMin : uniforms.squeezeMin.value);\n  }, [props.squeezeMin]);\n  React.useEffect(function () {\n    var _props$squeezeMax;\n    return void (uniforms.squeezeMax.value = (_props$squeezeMax = props.squeezeMax) !== null && _props$squeezeMax !== void 0 ? _props$squeezeMax : uniforms.squeezeMax.value);\n  }, [props.squeezeMax]);\n  React.useEffect(function () {\n    return void (uniforms.stroke.value = props.stroke ? new THREE.Color(props.stroke) : uniforms.stroke.value);\n  }, [props.stroke]);\n  React.useEffect(function () {\n    return void (uniforms.fill.value = props.fill ? new THREE.Color(props.fill) : uniforms.fill.value);\n  }, [props.fill]);\n  React.useEffect(function () {\n    return void (uniforms.backfaceStroke.value = props.backfaceStroke ? new THREE.Color(props.backfaceStroke) : uniforms.backfaceStroke.value);\n  }, [props.backfaceStroke]);\n}\nexport { WireframeMaterial, WireframeMaterialShaders, setWireframeOverride, useWireframeUniforms };","map":{"version":3,"names":["THREE","React","shaderMaterial","WireframeMaterialShaders","uniforms","strokeOpacity","fillOpacity","fillMix","thickness","colorBackfaces","dashInvert","dash","dashRepeats","dashLength","squeeze","squeezeMin","squeezeMax","stroke","Color","backfaceStroke","fill","vertex","fragment","WireframeMaterial","setWireframeOverride","material","onBeforeCompile","shader","_objectSpread","vertexShader","replace","fragmentShader","side","DoubleSide","transparent","useWireframeUniforms","props","useEffect","_props$fillOpacity","value","_props$fillMix","_props$strokeOpacity","_props$thickness","_props$dashRepeats","_props$dashLength","_props$squeezeMin","_props$squeezeMax"],"sources":["C:/Users/jouai/Desktop/Telecom/S9/image/Projet vision/TRYON/node_modules/@react-three/drei/materials/WireframeMaterial.js"],"sourcesContent":["import * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from '../core/shaderMaterial.js';\n\nconst WireframeMaterialShaders = {\n  uniforms: {\n    strokeOpacity: 1,\n    fillOpacity: 0.25,\n    fillMix: 0,\n    thickness: 0.05,\n    colorBackfaces: false,\n    dashInvert: true,\n    dash: false,\n    dashRepeats: 4,\n    dashLength: 0.5,\n    squeeze: false,\n    squeezeMin: 0.2,\n    squeezeMax: 1,\n    stroke: new THREE.Color('#ff0000'),\n    backfaceStroke: new THREE.Color('#0000ff'),\n    fill: new THREE.Color('#00ff00')\n  },\n  vertex:\n  /* glsl */\n  `\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  `,\n  fragment:\n  /* glsl */\n  `\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  `\n};\nconst WireframeMaterial = shaderMaterial(WireframeMaterialShaders.uniforms, WireframeMaterialShaders.vertex +\n/* glsl */\n`\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  `, WireframeMaterialShaders.fragment +\n/* glsl */\n`\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  `);\nfunction setWireframeOverride(material, uniforms) {\n  material.onBeforeCompile = shader => {\n    shader.uniforms = { ...shader.uniforms,\n      ...uniforms\n    };\n    shader.vertexShader = shader.vertexShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.vertex}\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('void main() {', `\n\t\t  ${WireframeMaterialShaders.fragment}\n\t\t  void main() {\n\t\t`);\n    shader.fragmentShader = shader.fragmentShader.replace('#include <color_fragment>',\n    /* glsl */\n    `\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t`);\n  };\n\n  material.side = THREE.DoubleSide;\n  material.transparent = true;\n}\nfunction useWireframeUniforms(uniforms, props) {\n  React.useEffect(() => {\n    var _props$fillOpacity;\n\n    return void (uniforms.fillOpacity.value = (_props$fillOpacity = props.fillOpacity) !== null && _props$fillOpacity !== void 0 ? _props$fillOpacity : uniforms.fillOpacity.value);\n  }, [props.fillOpacity]);\n  React.useEffect(() => {\n    var _props$fillMix;\n\n    return void (uniforms.fillMix.value = (_props$fillMix = props.fillMix) !== null && _props$fillMix !== void 0 ? _props$fillMix : uniforms.fillMix.value);\n  }, [props.fillMix]);\n  React.useEffect(() => {\n    var _props$strokeOpacity;\n\n    return void (uniforms.strokeOpacity.value = (_props$strokeOpacity = props.strokeOpacity) !== null && _props$strokeOpacity !== void 0 ? _props$strokeOpacity : uniforms.strokeOpacity.value);\n  }, [props.strokeOpacity]);\n  React.useEffect(() => {\n    var _props$thickness;\n\n    return void (uniforms.thickness.value = (_props$thickness = props.thickness) !== null && _props$thickness !== void 0 ? _props$thickness : uniforms.thickness.value);\n  }, [props.thickness]);\n  React.useEffect(() => void (uniforms.colorBackfaces.value = !!props.colorBackfaces), [props.colorBackfaces]);\n  React.useEffect(() => void (uniforms.dash.value = !!props.dash), [props.dash]);\n  React.useEffect(() => void (uniforms.dashInvert.value = !!props.dashInvert), [props.dashInvert]);\n  React.useEffect(() => {\n    var _props$dashRepeats;\n\n    return void (uniforms.dashRepeats.value = (_props$dashRepeats = props.dashRepeats) !== null && _props$dashRepeats !== void 0 ? _props$dashRepeats : uniforms.dashRepeats.value);\n  }, [props.dashRepeats]);\n  React.useEffect(() => {\n    var _props$dashLength;\n\n    return void (uniforms.dashLength.value = (_props$dashLength = props.dashLength) !== null && _props$dashLength !== void 0 ? _props$dashLength : uniforms.dashLength.value);\n  }, [props.dashLength]);\n  React.useEffect(() => void (uniforms.squeeze.value = !!props.squeeze), [props.squeeze]);\n  React.useEffect(() => {\n    var _props$squeezeMin;\n\n    return void (uniforms.squeezeMin.value = (_props$squeezeMin = props.squeezeMin) !== null && _props$squeezeMin !== void 0 ? _props$squeezeMin : uniforms.squeezeMin.value);\n  }, [props.squeezeMin]);\n  React.useEffect(() => {\n    var _props$squeezeMax;\n\n    return void (uniforms.squeezeMax.value = (_props$squeezeMax = props.squeezeMax) !== null && _props$squeezeMax !== void 0 ? _props$squeezeMax : uniforms.squeezeMax.value);\n  }, [props.squeezeMax]);\n  React.useEffect(() => void (uniforms.stroke.value = props.stroke ? new THREE.Color(props.stroke) : uniforms.stroke.value), [props.stroke]);\n  React.useEffect(() => void (uniforms.fill.value = props.fill ? new THREE.Color(props.fill) : uniforms.fill.value), [props.fill]);\n  React.useEffect(() => void (uniforms.backfaceStroke.value = props.backfaceStroke ? new THREE.Color(props.backfaceStroke) : uniforms.backfaceStroke.value), [props.backfaceStroke]);\n}\n\nexport { WireframeMaterial, WireframeMaterialShaders, setWireframeOverride, useWireframeUniforms };\n"],"mappings":";;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,cAAc;AAEvB,IAAMC,wBAAwB,GAAG;EAC/BC,QAAQ,EAAE;IACRC,aAAa,EAAE,CAAC;IAChBC,WAAW,EAAE,IAAI;IACjBC,OAAO,EAAE,CAAC;IACVC,SAAS,EAAE,IAAI;IACfC,cAAc,EAAE,KAAK;IACrBC,UAAU,EAAE,IAAI;IAChBC,IAAI,EAAE,KAAK;IACXC,WAAW,EAAE,CAAC;IACdC,UAAU,EAAE,GAAG;IACfC,OAAO,EAAE,KAAK;IACdC,UAAU,EAAE,GAAG;IACfC,UAAU,EAAE,CAAC;IACbC,MAAM,EAAE,IAAIjB,KAAK,CAACkB,KAAK,CAAC,SAAS,CAAC;IAClCC,cAAc,EAAE,IAAInB,KAAK,CAACkB,KAAK,CAAC,SAAS,CAAC;IAC1CE,IAAI,EAAE,IAAIpB,KAAK,CAACkB,KAAK,CAAC,SAAS;EACjC,CAAC;EACDG,MAAM,EAEL;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;EACFC,QAAQ,EAEP;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAMC,iBAAiB,GAAGrB,cAAc,CAACC,wBAAwB,CAACC,QAAQ,EAAED,wBAAwB,CAACkB,MAAM,GAE1G;AACD;AACA;AACA;AACA;AACA,GAAG,EAAElB,wBA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}